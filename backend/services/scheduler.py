import schedule
import time
import threading
from datetime import datetime
from services.api_scraper import supermarket_api
from models.product_model import product_model

class DatabaseScheduler:
    """
    VERSI√ìN H√çBRIDA: Mantiene funcionalidad original + Agrega historial de precios
    """
    
    def __init__(self):
        self.is_running = False
        self.scheduler_thread = None
        
        # T√©rminos populares para actualizar autom√°ticamente
        self.popular_terms = [
            # ALIMENTOS B√ÅSICOS
            "leche", "arroz", "aceite", "az√∫car", "sal", "pan", "huevos",
            "pollo", "carne", "pescado", "tomate", "cebolla", "papa",
            "yogurt", "queso", "mantequilla", "at√∫n", "pasta", "fideos",
            
            # LIMPIEZA Y HOGAR
            "detergente", "jab√≥n", "shampoo", "papel higi√©nico", "suavizante",
            "desinfectante", "cloro", "esponja", "bolsas basura", "servilletas",
            
            # SNACKS Y DULCES
            "galletas", "cereales", "chocolate", "caramelos", "papas fritas",
            "helados", "tortas", "pasteles", "chicles",
            
            # BEBIDAS
            "agua", "gaseosa", "cerveza", "vino", "jugo", "caf√©", "t√©",
            "energizante", "isot√≥nico",
            
            # FRUTAS Y VERDURAS
            "lim√≥n", "pl√°tano", "manzana", "naranja", "zanahoria", "lechuga",
            "br√≥coli", "apio", "palta", "fresa", "uva", "pi√±a",
            
            # CUIDADO PERSONAL
            "crema", "perfume", "desodorante", "pasta dental", "cepillo",
            "protector solar", "vitaminas", "medicamentos",
            
            # HOGAR Y DECORACI√ìN
            "vela", "plantas", "macetas", "cuadros", "almohadas", "toallas",
            
            # TECNOLOG√çA Y ELECTR√ìNICOS
            "cable", "cargador", "aud√≠fono", "bater√≠a", "bombilla",
            
            # MASCOTAS
            "comida perro", "comida gato", "arena gato", "juguete mascota",
            
            # ROPA Y ACCESORIOS
            "medias", "ropa interior", "pijama", "zapatos", "cartera"
        ]
    
    def start_scheduler(self):
        """
        Inicia el programador de tareas
        """
        if self.is_running:
            print("‚ö†Ô∏è El programador ya est√° ejecut√°ndose")
            return

        # Programar actualizaci√≥n diaria a las 20:40 (para testing)
        schedule.every().day.at("20:40").do(self.daily_database_update_with_history)
        
        # Iniciar thread del programador
        self.is_running = True
        self.scheduler_thread = threading.Thread(target=self._run_scheduler)
        self.scheduler_thread.daemon = True
        self.scheduler_thread.start()
        
        print("‚úÖ Programador de tareas iniciado")
        print("   - Actualizaci√≥n diaria: 05:00 (testing)")
    
    def stop_scheduler(self):
        """
        Detiene el programador de tareas
        """
        self.is_running = False
        schedule.clear()
        print("üõë Programador de tareas detenido")
    
    def _run_scheduler(self):
        """
        Ejecuta el loop del programador
        """
        while self.is_running:
            schedule.run_pending()
            time.sleep(60)  # Verificar cada minuto

    def daily_database_update(self):
        """
        M√âTODO ORIGINAL QUE FUNCIONABA - Sin modificar
        """
        try:
            print("üåÖ Iniciando actualizaci√≥n diaria de la base de datos...")
            start_time = datetime.now()
            
            total_saved = 0
            total_updated = 0
            total_errors = 0
            
            # Procesar cada t√©rmino popular
            for i, term in enumerate(self.popular_terms):
                try:
                    print(f"üîç Procesando {i+1}/{len(self.popular_terms)}: {term}")
                    
                    # Buscar productos
                    products_data = supermarket_api.search_products(
                        query=term,
                        limit=100
                    )
                    
                    # Guardar en base de datos (M√âTODO ORIGINAL)
                    save_result = product_model.save_products(products_data, term)
                    
                    if save_result["success"]:
                        total_saved += save_result["saved_count"]
                        total_updated += save_result["updated_count"]
                        print(f"   ‚úÖ {save_result['saved_count']} nuevos, {save_result['updated_count']} actualizados")
                    else:
                        total_errors += 1
                        print(f"   ‚ùå Error guardando productos para '{term}'")
                    
                    # Pausa entre t√©rminos
                    time.sleep(3)
                    
                except Exception as e:
                    total_errors += 1
                    print(f"   ‚ùå Error procesando '{term}': {e}")
                    continue
            
            # Actualizar timestamp
            product_model.update_last_database_update()
            
            # Calcular tiempo total
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds() / 60
            
            # Log de resumen
            print("‚úÖ Actualizaci√≥n diaria completada:")
            print(f"   - Duraci√≥n: {duration:.1f} minutos")
            print(f"   - Productos nuevos: {total_saved}")
            print(f"   - Productos actualizados: {total_updated}")
            print(f"   - Errores: {total_errors}")
            print(f"   - T√©rminos procesados: {len(self.popular_terms)}")
            
            # Guardar estad√≠sticas de la actualizaci√≥n
            self._save_update_stats(
                duration, total_saved, total_updated, total_errors
            )
            
        except Exception as e:
            print(f"‚ùå Error en actualizaci√≥n diaria: {e}")

    def daily_database_update_with_history(self):
        """
        NUEVA VERSI√ìN: Actualizaci√≥n diaria + creaci√≥n de historial de precios
        """
        try:
            print("üåÖ Iniciando actualizaci√≥n diaria CON HISTORIAL...")
            start_time = datetime.now()
            
            total_saved = 0
            total_updated = 0
            total_errors = 0
            total_price_changes = 0
            total_alerts_created = 0
            
            # Procesar cada t√©rmino popular
            for i, term in enumerate(self.popular_terms):
                try:
                    print(f"üîç Procesando {i+1}/{len(self.popular_terms)}: {term}")
                    
                    # 1. PASO 1: Actualizaci√≥n normal (que sabemos que funciona)
                    products_data = supermarket_api.search_products(query=term, limit=100)
                    
                    if not products_data:
                        print(f"   ‚ö†Ô∏è No se encontraron productos para '{term}'")
                        continue
                    
                    # Guardar usando el m√©todo original
                    save_result = product_model.save_products(products_data, term)
                    
                    if save_result["success"]:
                        total_saved += save_result["saved_count"]
                        total_updated += save_result["updated_count"]
                        print(f"   ‚úÖ Guardado: {save_result['saved_count']} nuevos, {save_result['updated_count']} actualizados")
                        
                        # 2. PASO 2: Crear historial de precios DESPU√âS del guardado exitoso
                        history_result = self._create_price_history_for_term(products_data, term)
                        total_price_changes += history_result['price_changes']
                        total_alerts_created += history_result['alerts_created']
                        
                    else:
                        total_errors += 1
                        print(f"   ‚ùå Error guardando productos para '{term}'")
                    
                    # Pausa entre t√©rminos
                    time.sleep(3)
                    
                except Exception as e:
                    total_errors += 1
                    print(f"   ‚ùå Error procesando '{term}': {e}")
                    continue
            
            # Actualizar timestamp
            product_model.update_last_database_update()
            
            # Calcular tiempo total
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds() / 60
            
            # Log de resumen AMPLIADO
            print("‚úÖ Actualizaci√≥n diaria CON HISTORIAL completada:")
            print(f"   - Duraci√≥n: {duration:.1f} minutos")
            print(f"   - Productos nuevos: {total_saved}")
            print(f"   - Productos actualizados: {total_updated}")
            print(f"   - Cambios de precio detectados: {total_price_changes}")
            print(f"   - Alertas creadas: {total_alerts_created}")
            print(f"   - Errores: {total_errors}")
            print(f"   - T√©rminos procesados: {len(self.popular_terms)}")
            
            # Guardar estad√≠sticas ampliadas
            self._save_update_stats_extended(
                duration, total_saved, total_updated, total_errors,
                total_price_changes, total_alerts_created
            )
            
        except Exception as e:
            print(f"‚ùå Error en actualizaci√≥n con historial: {e}")

    def _create_price_history_for_term(self, products_data, term):
        """
        NUEVO: Crea historial de precios para productos de un t√©rmino
        Se ejecuta DESPU√âS de que save_products() haya funcionado
        """
        result = {
            'price_changes': 0,
            'alerts_created': 0
        }
        
        try:
            # Extraer productos de la estructura de respuesta
            all_products = []
            
            if isinstance(products_data, dict):
                # Si es diccionario por supermercados
                for supermarket_key, supermarket_data in products_data.items():
                    if isinstance(supermarket_data, dict) and supermarket_data.get("success"):
                        products = supermarket_data.get("products", [])
                        if products:
                            all_products.extend(products)
            elif isinstance(products_data, list):
                # Si es lista directa
                all_products = products_data
            
            if not all_products:
                return result
            
            print(f"     üîç Verificando historial para {len(all_products)} productos")
            
            # Procesar cada producto para historial
            for product in all_products:
                try:
                    if not product or not product.get("unique_id"):
                        continue
                    
                    # Obtener producto existente de la DB
                    existing = product_model.get_product_by_unique_id(product.get("unique_id"))
                    
                    if not existing:
                        continue  # Es producto nuevo, no hay historial que crear
                    
                    # Comparar precios
                    old_price = float(existing.get("price", 0))
                    new_price = float(product.get("price", 0))
                    
                    if old_price > 0 and new_price > 0 and old_price != new_price:
                        # HAY CAMBIO DE PRECIO
                        print(f"     üìä Cambio detectado: {product.get('name')} S/{old_price:.2f} ‚Üí S/{new_price:.2f}")
                        
                        # Crear entrada en historial
                        if self._save_price_history_entry(product, old_price, new_price):
                            result['price_changes'] += 1
                            
                            # Intentar crear alerta si el cambio es significativo
                            if self._try_create_alert(product, old_price, new_price):
                                result['alerts_created'] += 1
                
                except Exception as e:
                    print(f"     ‚ö†Ô∏è Error procesando producto para historial: {e}")
                    continue
            
            if result['price_changes'] > 0:
                print(f"     ‚úÖ Historial: {result['price_changes']} cambios, {result['alerts_created']} alertas")
            
            return result
            
        except Exception as e:
            print(f"   ‚ùå Error creando historial para '{term}': {e}")
            return result

    def _save_price_history_entry(self, product, old_price, new_price):
        """Guarda entrada en historial de precios"""
        try:
            price_history_entry = {
                "product_unique_id": product["unique_id"],
                "product_name": product.get("name", "Producto desconocido"),
                "old_price": old_price,
                "new_price": new_price,
                "price_difference": round(new_price - old_price, 2),
                "percentage_change": round(((new_price - old_price) / old_price) * 100, 1),
                "supermarket": product.get("supermarket"),
                "supermarket_key": product.get("supermarket_key"),
                "timestamp": datetime.now().isoformat(),
                "source": "scheduled_update"
            }
            
            product_model.price_history_collection.insert_one(price_history_entry)
            return True
            
        except Exception as e:
            print(f"     ‚ùå Error guardando historial: {e}")
            return False

    def _try_create_alert(self, product, old_price, new_price):
        """Intenta crear alerta si el cambio es significativo"""
        try:
            # Calcular cambio porcentual
            percentage_change = abs((new_price - old_price) / old_price * 100)
            absolute_change = abs(new_price - old_price)
            
            # Solo crear alerta si es significativo
            if percentage_change >= 5.0 and absolute_change >= 0.50:
                from models.alert_model import alert_model
                
                alert_id = alert_model.create_price_change_alert(product, old_price, new_price)
                
                if alert_id:
                    return True
            
            return False
            
        except Exception as e:
            print(f"     ‚ö†Ô∏è Error creando alerta: {e}")
            return False
    
    def weekly_cleanup(self):
        """
        Limpieza semanal de datos antiguos
        """
        try:
            print("üßπ Iniciando limpieza semanal...")
            
            # Limpiar productos muy antiguos (m√°s de 15 d√≠as)
            deleted_products = product_model.clean_old_products(days_old=15)
            
            # Limpiar historial de b√∫squedas muy antiguo (m√°s de 30 d√≠as)
            from datetime import timedelta
            cutoff_date = datetime.now() - timedelta(days=30)
            
            deleted_searches = product_model.search_history_collection.delete_many({
                "timestamp": {"$lt": cutoff_date.isoformat()}
            }).deleted_count
            
            # Limpiar historial de precios muy antiguo (m√°s de 45 d√≠as)
            deleted_prices = product_model.price_history_collection.delete_many({
                "timestamp": {"$lt": (datetime.now() - timedelta(days=45)).isoformat()}
            }).deleted_count
            
            # Limpiar alertas muy antiguas (m√°s de 30 d√≠as)
            deleted_alerts = 0
            try:
                from models.alert_model import alert_model
                deleted_alerts = alert_model.cleanup_old_alerts(days_old=30)
            except Exception as e:
                print(f"   ‚ö†Ô∏è Error limpiando alertas: {e}")
            
            print("‚úÖ Limpieza semanal completada:")
            print(f"   - Productos eliminados: {deleted_products}")
            print(f"   - B√∫squedas eliminadas: {deleted_searches}")
            print(f"   - Precios eliminados: {deleted_prices}")
            print(f"   - Alertas eliminadas: {deleted_alerts}")
            
        except Exception as e:
            print(f"‚ùå Error en limpieza semanal: {e}")
    
    def _save_update_stats(self, duration, saved, updated, errors):
        """
        Guarda estad√≠sticas b√°sicas de la actualizaci√≥n (versi√≥n original)
        """
        try:
            from services.db import db
            stats_collection = db['update_statistics']
            
            stats_doc = {
                "timestamp": datetime.now().isoformat(),
                "date": datetime.now().date().isoformat(),
                "duration_minutes": round(duration, 1),
                "products_saved": saved,
                "products_updated": updated,
                "errors": errors,
                "terms_processed": len(self.popular_terms),
                "update_type": "daily_automatic"
            }
            
            stats_collection.insert_one(stats_doc)
            
        except Exception as e:
            print(f"Error guardando estad√≠sticas: {e}")

    def _save_update_stats_extended(self, duration, saved, updated, errors, price_changes=0, alerts_created=0):
        """
        Guarda estad√≠sticas ampliadas incluyendo historial y alertas
        """
        try:
            from services.db import db
            stats_collection = db['update_statistics']
            
            stats_doc = {
                "timestamp": datetime.now().isoformat(),
                "date": datetime.now().date().isoformat(),
                "duration_minutes": round(duration, 1),
                "products_saved": saved,
                "products_updated": updated,
                "price_changes_detected": price_changes,
                "alerts_created": alerts_created,
                "errors": errors,
                "terms_processed": len(self.popular_terms),
                "update_type": "daily_automatic_with_history",
                "efficiency": {
                    "products_per_minute": round((saved + updated) / max(duration, 1), 1),
                    "success_rate": round((saved + updated) / max(saved + updated + errors, 1) * 100, 1),
                    "alert_creation_rate": round(alerts_created / max(price_changes, 1) * 100, 1) if price_changes > 0 else 0
                }
            }
            
            stats_collection.insert_one(stats_doc)
            print(f"   üìä Estad√≠sticas guardadas")
            
        except Exception as e:
            print(f"Error guardando estad√≠sticas ampliadas: {e}")
    
    def force_update_now(self):
        """
        Fuerza una actualizaci√≥n inmediata (para testing)
        """
        print("üîÑ Forzando actualizaci√≥n inmediata...")
        thread = threading.Thread(target=self.daily_database_update_with_history)
        thread.daemon = True
        thread.start()
        return "Actualizaci√≥n con historial iniciada en segundo plano"

    def force_update_original(self):
        """
        Fuerza actualizaci√≥n con el m√©todo original (sin historial)
        """
        print("üîÑ Forzando actualizaci√≥n ORIGINAL...")
        thread = threading.Thread(target=self.daily_database_update)
        thread.daemon = True
        thread.start()
        return "Actualizaci√≥n original iniciada"

    def test_single_term_with_history(self, term="leche"):
        """
        Prueba un t√©rmino con creaci√≥n de historial
        """
        try:
            print(f"üß™ Probando '{term}' con historial...")
            
            # Obtener productos
            products_data = supermarket_api.search_products(query=term, limit=10)
            
            if not products_data:
                print("‚ùå No se obtuvieron productos")
                return {"success": False, "message": "Sin productos"}
            
            # Guardar usando m√©todo original
            save_result = product_model.save_products(products_data, term)
            print(f"üì¶ Guardado: {save_result}")
            
            # Crear historial
            history_result = self._create_price_history_for_term(products_data, term)
            print(f"üìä Historial: {history_result}")
            
            return {
                "success": True,
                "save_result": save_result,
                "history_result": history_result
            }
            
        except Exception as e:
            print(f"‚ùå Error en prueba: {e}")
            return {"success": False, "error": str(e)}

# Crear instancia global
database_scheduler = DatabaseScheduler()